<!DOCTYPE html>
<html>
<head>
    <title>Three.js Rotation Test</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/three@latest/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@latest/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        renderer.setClearColor(0xadd8e6);

        const loader = new THREE.GLTFLoader();

        let model;
        let isRotating = false;
        let previousTouchX = 0;
        let previousTouchY = 0;
        let currentTouchX = 0;
        let currentTouchY = 0;

        loader.load('models/bocolla/bocolla.gltf', (gltf) => {
            model = gltf.scene;
            scene.add(model);
            camera.position.z = 5;

// Add a directional light that targets the model:
const directionalLight = new THREE.DirectionalLight(0xffffff, 1); // Increased intensity
    scene.add(directionalLight);

    // Set the light's target to the model (after the model is loaded):
    directionalLight.target = model; // Very important: target the model
    directionalLight.position.set(5, 5, 5); // Adjust light position

    // Optional: Add a helper to visualize the light's direction (for debugging)
    const directionalLightHelper = new THREE.DirectionalLightHelper(directionalLight, 5);
    scene.add(directionalLightHelper);


    const ambientLight = new THREE.AmbientLight(0x404040); // Soft white light
    scene.add(ambientLight);


            function animate() {
              requestAnimationFrame(animate);

              if (isRotating && model) {
                  const deltaX = currentTouchX - previousTouchX;
                  const deltaY = currentTouchY - previousTouchY;

                  model.rotation.y += deltaX * 0.01; // Rotate around Y-axis (vertical)
                  model.rotation.x += deltaY * 0.01; // Rotate around X-axis (horizontal)

                  previousTouchX = currentTouchX;
                  previousTouchY = currentTouchY;
              }

              renderer.render(scene, camera);
          }

            animate();

        }, (xhr) => { }, (error) => {
            console.error('Error loading GLTF:', error);
        });

        document.addEventListener('touchstart', (event) => {
    if (event.touches.length === 1 && model) {
        isRotating = true;
        currentTouchX = event.touches[0].clientX;
        currentTouchY = event.touches[0].clientY;
        previousTouchX = event.touches[0].clientX;
        previousTouchY = event.touches[0].clientY;
    }
});

document.addEventListener('touchmove', (event) => {
    if (event.touches.length === 1 && isRotating) {
        currentTouchX = event.touches[0].clientX;
        currentTouchY = event.touches[0].clientY;
    }
});

document.addEventListener('touchend', () => {
    isRotating = false;
});

// Optional: Mouse Control (for testing on desktop)
document.addEventListener('mousedown', (event) => {
    isRotating = true;
    previousTouchX = event.clientX;
    previousTouchY = event.clientY;
});

document.addEventListener('mousemove', (event) => {
    if (isRotating) {
        const deltaX = event.clientX - previousTouchX;
        const deltaY = event.clientY - previousTouchY;
        model.rotation.y += deltaX * 0.01;
        model.rotation.x += deltaY * 0.01;
        previousTouchX = event.clientX;
        previousTouchY = event.clientY;
    }
});

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>